## 时间复杂度和空间复杂度

### 时间复杂度

一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。

没有循环语句，记作`O(1)`，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作`O（n）`，也叫线性阶。

常见的时间复杂度有：

- `O(1)`: Constant Complexity: Constant 常数复杂度
- `O(log n)`: Logarithmic Complexity: 对数复杂度
- `O(n)`: Linear Complexity: 线性时间复杂度
- `O(n^2)`: N square Complexity 平⽅方
- `O(n^3)`: N square Complexity ⽴立⽅方
- `O(2^n)`: Exponential Growth 指数
- `O(n!)`: Factorial 阶乘

当**数据量足够大**时，**从上到下依次递增**

![img](数据结构.assets/16cac3540b752726tplv-t2oaga2asx-watermark.awebp)

### 空间复杂度

一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。

一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。

# 数据结构

## 一、what

数据结构即数据元素相互之间存在的一种和多种特定的关系集合。

一般你可以从两个维度来理解它，**逻辑结构和存储结构**。

### 逻辑结构

就是数据之间的关系。

逻辑结构大概统一的可以分成两种：线性结构、非线性结构。

#### 线性结构

线性结构：是一个有序数据元素的集合。 其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。

##### 常用的线性结构

栈，队列，链表，线性表。

#### 非线性结构

各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。

##### 常见的非线性结构

二维数组，树等

### 存储结构

逻辑结构指的是数据间的关系，而存储结构是逻辑结构用计算机语言的实现。

常见的存储结构有顺序存储、链式存储、索引存储以及散列存储。

例如：数组在内存中的位置是连续的，它就属于顺序存储；链表是主动建立数据间的关联关系的，在内存中却不一定是连续的，它属于链式存储；还有顺序和逻辑上都不存在顺序关系，但是你可以通过一定的方式去放问它的哈希表，数据散列存储。



## 二、二叉树

树是用来模拟具有树状结构性质的数据集合。

二叉树是一种典型的树树状结构。

如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。

### 1.二叉树遍历

> 重点中的重点，最好同时掌握递归和非递归版本，递归版本很容易书写，但是真正考察基本功的是非递归版本。

三道题的解决思路可统一，模板也极其相似

1. 将二叉树分为“左”（包括一路向左，经过的所有实际左+根）、“右”（包括实际的右）两种节点
2. 使用同样的顺序将“左”节点入栈
3. 在合适的时机转向（转向后，“右”节点即成为“左”节点）、访问节点、或出栈

先序和中序的情况是极其相似的。

- 先序的实际顺序：根左右
- 中序的实际顺序：左根右

使用上述思路，先序和中序的遍历顺序可统一为：“左”“右”。

给我们的直观感觉是代码也会比较相似。实际情况正是如此，先序与中序的区别只在于对“左”节点的访问上。

#### 中序遍历

从叶子节点开始，左-中-右

#### 前序遍历

从根节点开始，中-左-右

不需要入栈，每次遍历到“左”节点，立即输出即可。

需要注意的是，遍历到最左下的节点时，实际上输出的已经不再是实际的根节点，而是实际的左节点。这符合先序的定义。

#### 后序遍历

从叶子节点开始，左-右-中

入栈顺序不变，我们只需要考虑第3点的变化（`合适时机转向`）。出栈的对象一定都是“左”节点（“右”节点会在转向后称为“左”节点，然后入栈），也就是实际的左或根；实际的左可以当做左右子树都为null的根，所以我们只需要分析实际的根。

对于实际的根，需要保证先后访问了左子树、右子树之后，才能访问根。实际的右节点、左节点、根节点都会成为“左”节点入栈，所以我们只需要**在出栈之前，将该节点视作实际的根节点，并检查其右子树是否已被访问**即可。如果不存在右子树，或右子树已被访问了，那么可以访问根节点，出栈，并不需要转向；如果还没有访问，就转向，使其“右”节点成为“左”节点，等着它先被访问之后，再来访问根节点。 

所以，我们需要增加一个标志，记录右子树的访问情况。由于访问根节点前，一定先紧挨着访问了其右子树，所以我们只需要一个标志位。

### 2.重建二叉树

#### 思路

- 前序遍历：跟节点 + 左子树前序遍历 + 右子树前序遍历
- 中序遍历：左子树中序遍历 + 跟节点 + 右字数中序遍历
- 后序遍历：左子树后序遍历 + 右子树后序遍历 + 跟节点

根据上面的规律：

- 前序遍历找到根结点`root`
- 找到`root`在中序遍历的位置 -> 左子树的长度和右子树的长度
- 截取左子树的中序遍历、右子树的中序遍历
- 截取左子树的前序遍历、右子树的前序遍历
- 递归重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如输入前序遍历序列`{1,2,4,7,3,5,6,8}`和中序遍历序列`{4,7,2,1,5,3,8,6}`，则重建二叉树并返回。

#### 求二叉树的遍历

给定一棵二叉树的前序遍历和中序遍历，求其后序遍历

输入描述:

两个字符串，其长度n均小于等于26。 第一行为前序遍历，第二行为中序遍历。 二叉树中的结点名称以大写字母表示：A，B，C....最多26个结点。

输出描述:

输入样例可能有多组，对于每组测试样例， 输出一行，为后序遍历的字符串。

#### 思路

和上面题目的思路基本相同

- 前序遍历找到根结点`root`
- 找到`root`在中序遍历的位置 -> 左子树的长度和右子树的长度
- 截取左子树的中序遍历、右子树的中序遍历
- 截取左子树的前序遍历、右子树的前序遍历
- 递归拼接二叉树的后序遍历

